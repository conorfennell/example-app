/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.2
 * apibuilder 0.14.75 app.apibuilder.io/paintbatch-com/example-app/0.2/http4s_0_20
 */
package com.paintbatch.models {

  /**
   * health of the service
   * 
   * @param status The health status of the service
   */
  final case class Healthcheck(
    status: com.paintbatch.models.Status
  )

  /**
   * health state of the service
   */
  sealed trait Status extends _root_.scala.Product with _root_.scala.Serializable

  object Status {

    case object Ok extends Status { override def toString = "ok" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends Status

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[Status] = scala.List(Ok)

    private[this]
    val byName: Map[String, Status] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Status = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Status] = byName.get(value.toLowerCase)

  }

}

package com.paintbatch.models {

  package object json {
    import io.circe.Decoder._
    import io.circe.Encoder._
    import scala.language.implicitConversions // See below - Make Scala 2.11 Either monadic
    import scala.util.Try
    import io.circe.{Json, JsonObject, Encoder, Decoder, DecodingFailure}
    import io.circe.syntax._
    import com.paintbatch.models.json._

    // Make Scala 2.11 Either monadic
    private[paintbatch] implicit def eitherOps[A,B](e: Either[A,B]) = cats.implicits.catsSyntaxEither(e)

    private[paintbatch] implicit val decodeUUID: Decoder[_root_.java.util.UUID] =
      Decoder.decodeString.emapTry(str => Try(_root_.java.util.UUID.fromString(str)))

    private[paintbatch] implicit val encodeUUID: Encoder[_root_.java.util.UUID] =
      Encoder.encodeString.contramap[_root_.java.util.UUID](uuid => uuid.toString)

    private[paintbatch] implicit val decodeInstant: Decoder[_root_.java.time.Instant] =
      Decoder.decodeString.emapTry(str => Try(_root_.java.time.OffsetDateTime.parse(str).toInstant))

    private[paintbatch] implicit val encodeInstant: Encoder[_root_.java.time.Instant] =
      Encoder.encodeString.contramap[_root_.java.time.Instant](_.toString)

    private[paintbatch] implicit val decodeLocalDate: Decoder[_root_.java.time.LocalDate] =
      Decoder.decodeString.emapTry(str => Try(_root_.java.time.LocalDate.parse(str)))

    private[paintbatch] implicit val encodeLocalDate: Encoder[_root_.java.time.LocalDate] =
      Encoder.encodeString.contramap[_root_.java.time.LocalDate](_.toString)

    implicit val jsonDecoderExampleAppStatus: Decoder[com.paintbatch.models.Status] =
      Decoder.decodeString.map(com.paintbatch.models.Status(_))

    implicit val jsonEncoderExampleAppStatus: Encoder[com.paintbatch.models.Status] =
      Encoder.encodeString.contramap[com.paintbatch.models.Status](_.toString)

    implicit def decodeExampleAppHealthcheck: Decoder[Healthcheck] = Decoder.instance { c =>
     for {
        status <- c.downField("status").as[com.paintbatch.models.Status]
      } yield {
        Healthcheck(
          status = status
        )
      }
    }

    implicit def encodeExampleAppHealthcheck: Encoder[Healthcheck] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("status" -> t.status.asJson)
      ).flatten)
    }
  }
}

package com.paintbatch {
import cats.effect._
import cats.implicits._
import io.circe.syntax._

  object Constants {

    val Namespace = "com.paintbatch"
    val UserAgent = "apibuilder 0.14.75 app.apibuilder.io/paintbatch-com/example-app/0.2/http4s_0_20"
    val Version = "0.2"
    val VersionMajor = 0

  }

  class Client[F[_]: Sync](
    val baseUrl: org.http4s.Uri,
    auth: scala.Option[com.paintbatch.Authorization] = None,
    defaultHeaders: Seq[(String, String)] = Nil,
    httpClient: org.http4s.client.Client[F]
  ) extends interfaces.Client[F] {
    import org.http4s.Response
    import com.paintbatch.models.json._


    def healthchecks: Healthchecks[F] = Healthchecks

    object Healthchecks extends Healthchecks[F] {
      override def getHealthcheck(
        requestHeaders: Seq[(String, String)] = Nil
      ): F[com.paintbatch.models.Healthcheck] = {
        val urlPath = Seq("_internal_", "healthcheck")

        _executeRequest[Unit, com.paintbatch.models.Healthcheck]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.com.paintbatch.Client.parseJson[F, com.paintbatch.models.Healthcheck]("com.paintbatch.models.Healthcheck", r)
          case r => Sync[F].raiseError(new com.paintbatch.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200"))
        }
      }
    }

    private lazy val defaultApiHeaders = Seq(
      ("User-Agent", Constants.UserAgent),
      ("X-Apidoc-Version", Constants.Version),
      ("X-Apidoc-Version-Major", Constants.VersionMajor.toString)
    )

    def apiHeaders: Seq[(String, String)] = defaultApiHeaders

    def modifyRequest(request: org.http4s.Request[F]): org.http4s.Request[F] = request

    implicit def circeJsonEncoder[F[_]: Sync, A](implicit encoder: io.circe.Encoder[A]) = org.http4s.circe.jsonEncoderOf[F, A]

    def _executeRequest[T, U](
      method: String,
      path: Seq[String],
      queryParameters: Seq[(String, String)] = Nil,
      requestHeaders: Seq[(String, String)] = Nil,
      body: Option[T] = None,
      formBody : Option[org.http4s.UrlForm] = None
    )(handler: org.http4s.Response[F] => F[U]
    )(implicit encoder: io.circe.Encoder[T]): F[U] = {
      import org.http4s.QueryParamEncoder._

      val m = org.http4s.Method.fromString(method) match {
        case Right(m) => m
        case Left(e) => sys.error(e.toString)
      }

      val headers = org.http4s.Headers((
        apiHeaders ++
        defaultHeaders ++
        requestHeaders
      ).toList.map { case (k, v) => org.http4s.Header(k, v) })

      val queryMap = queryParameters.groupBy(_._1).map { case (k, v) => k -> v.map(_._2) }
      val uri = path.foldLeft(baseUrl){ case (uri, segment) => uri / segment }.setQueryParams(queryMap)

      val request = org.http4s.Request[F](method = m,
                                       uri = uri,
                                       headers = headers)

      val reqAndMaybeAuth = auth.fold(request) {
        case Authorization.Basic(username, passwordOpt) => {
          val userpass = s"$username:${passwordOpt.getOrElse("")}"
          val token = java.util.Base64.getEncoder.encodeToString(userpass.getBytes(java.nio.charset.StandardCharsets.ISO_8859_1))
          request.putHeaders(org.http4s.Header("Authorization", s"Basic $token"))
        }
        case a => sys.error("Invalid authorization scheme[" + a.getClass + "]")
      }

      val reqAndMaybeAuthAndBody =
        if (formBody.nonEmpty) formBody.fold(reqAndMaybeAuth)(reqAndMaybeAuth.withEntity)
        else body.fold(reqAndMaybeAuth)(reqAndMaybeAuth.withEntity)

      httpClient.fetch(modifyRequest(reqAndMaybeAuthAndBody))(handler)
    }
  }

  object Client {
    import cats.effect._

    implicit def circeJsonDecoder[F[_]: Sync, A](implicit decoder: io.circe.Decoder[A]) = org.http4s.circe.jsonOf[F, A]

    def parseJson[F[_]: Sync, T](
      className: String,
      r: org.http4s.Response[F]
    )(implicit decoder: io.circe.Decoder[T]): F[T] = r.attemptAs[T].value.flatMap {
      case Right(value) => Sync[F].pure(value)
      case Left(error) => Sync[F].raiseError(new com.paintbatch.errors.FailedRequest(r.status.code, s"Invalid json for class[" + className + "]", None, error))
    }
  }

  sealed trait Authorization extends _root_.scala.Product with _root_.scala.Serializable
  object Authorization {
    final case class Basic(username: String, password: Option[String] = None) extends Authorization
  }

  package interfaces {

    trait Client[F[_]] {
      def baseUrl: org.http4s.Uri
      def healthchecks: com.paintbatch.Healthchecks[F]
    }

  }

  trait Healthchecks[F[_]] {
    /**
     * GET health of service
     */
    def getHealthcheck(
      requestHeaders: Seq[(String, String)] = Nil
    ): F[com.paintbatch.models.Healthcheck]
  }

  package errors {

    final case class FailedRequest(responseCode: Int, message: String, requestUri: Option[_root_.java.net.URI] = None, parent: Exception = null) extends _root_.java.lang.Exception(s"HTTP $responseCode: $message", parent)

  }
}